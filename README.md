# test-wallet-balance-service

## Тестовое задание:

Напишите приложение, которое по REST принимает запрос вида
```
POST api/v1/wallet
{
  walletId: UUID,
  operationType: DEPOSIT or WITHDRAW,
  amount: 1000
}
```
после выполнять логику по изменению счета в базе данных

также есть возможность получить баланс кошелька
```
GET api/v1/wallets/{WALLET_UUID}
```

стек:
- java 8-17
- Spring 3
- Postgresql

Дополнительные требования:
- Должны быть написаны миграции для базы данных с помощью liquibase
- Обратите особое внимание проблемам при работе в конкурентной среде (1000 RPS по
одному кошельку). Ни один запрос не должен быть не обработан (50Х error)
- Предусмотрите соблюдение формата ответа для заведомо неверных запросов, когда
кошелька не существует, не валидный json, или недостаточно средств.
- приложение должно запускаться в докер контейнере, база данных тоже, вся система
должна подниматься с помощью docker-compose
- предусмотрите возможность настраивать различные параметры как на стороне
приложения так и базы данных без пересборки контейнеров.
- эндпоинты должны быть покрыты тестами.

Все возникающие вопросы по заданию решать самостоятельно, по своему
усмотрению.

## Описание работы сервиса:
Сервис может быть запущен в 2х режимах:

1) Стандартный (без дополнительного профиля) - обрабатывает запросы как стандартное приложение, в порядке их получения.

При получении запросов к одному и тому же ресурсу (тому же wallet) - есть механизм оптимистичных блокировок и ретраев (не более 3х).

2) Группировочный (с профилем balance-grouped) - потоки томката регистрируют запрос на получение/изменение данных в отдельной структуре.

При получении запросов к одному и тому же ресурсу (тому же wallet) - запросы группируются и обрабатываются по очереди в рамках одной транзакции отдельными воркер-потоками (количество настраивается).
Таким образом, 1000 запросов к одному и тому же кошельку будет обработано практически так же быстро, как и 1 запрос (при условии, что вся работа была получена одним воркером в виде одной группы).

Нюансы: не должно быть конкурренции между несколькими репликами одного и того же сервиса за запросы к одному и тому же кошельку - необходим балансировщик, который бы распределял запросы гарантированно на тот же кошелек в тот же сервис.

## Запуск:
Склонировать проект, в проекте перейти в каталог docker в командной строке, поочередно выполнить следующие команды:
```
docker-compose build
docker-compose up
```
Первая команда приведет к сборке проекта в jar и последующей сборке образа с включенным в него jar.
Вторая - запускает данную команду.

При необходимости изменить конфигурацию - порядок действий следующий:
1) остановить сервисы в докере
2) изменить необходимую конфигурацию в environment
3) запустить (без пересборки контейнера) с помощью команды `docker-compose up`

## Конфигурация:
Стандартная конфигурация Spring Boot + кастомная.

Кастомная:
- SPRING_PROFILES_ACTIVE - если указан профиль balance-grouped, включается группировочный режим работы.
- APP_GROUPED_THREADS_COUNT=20 - количество воркер-потоков (если для группировочного режима работы).